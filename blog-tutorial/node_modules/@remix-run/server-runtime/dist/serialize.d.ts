import type { AppData } from "./data";
import type { TypedResponse } from "./responses";
declare type OmitIndexSignature<ObjectType> = {
    [KeyType in keyof ObjectType as {} extends Record<KeyType, unknown> ? never : KeyType]: ObjectType[KeyType];
};
declare type PickIndexSignature<ObjectType> = {
    [KeyType in keyof ObjectType as {} extends Record<KeyType, unknown> ? KeyType : never]: ObjectType[KeyType];
};
declare type Simplify<T> = {
    [KeyType in keyof T]: T[KeyType];
};
declare type RequiredFilter<Type, Key extends keyof Type> = undefined extends Type[Key] ? Type[Key] extends undefined ? Key : never : Key;
declare type OptionalFilter<Type, Key extends keyof Type> = undefined extends Type[Key] ? Type[Key] extends undefined ? never : Key : never;
declare type EnforceOptional<ObjectType> = Simplify<{
    [Key in keyof ObjectType as RequiredFilter<ObjectType, Key>]: ObjectType[Key];
} & {
    [Key in keyof ObjectType as OptionalFilter<ObjectType, Key>]?: Exclude<ObjectType[Key], undefined>;
}>;
declare type SimpleMerge<Destination, Source> = {
    [Key in keyof Destination | keyof Source]: Key extends keyof Source ? Source[Key] : Key extends keyof Destination ? Destination[Key] : never;
};
declare type Merge<Destination, Source> = EnforceOptional<SimpleMerge<PickIndexSignature<Destination>, PickIndexSignature<Source>> & SimpleMerge<OmitIndexSignature<Destination>, OmitIndexSignature<Source>>>;
declare type JsonPrimitive = string | number | boolean | String | Number | Boolean | null;
declare type NonJsonPrimitive = undefined | Function | symbol;
declare type IsAny<T> = 0 extends 1 & T ? true : false;
declare type Serialize<T> = IsAny<T> extends true ? any : T extends JsonPrimitive ? T : T extends NonJsonPrimitive ? never : T extends {
    toJSON(): infer U;
} ? U : T extends [] ? [] : T extends [unknown, ...unknown[]] ? SerializeTuple<T> : T extends ReadonlyArray<infer U> ? (U extends NonJsonPrimitive ? null : Serialize<U>)[] : T extends object ? SerializeObject<UndefinedToOptional<T>> : never;
/** JSON serialize [tuples](https://www.typescriptlang.org/docs/handbook/2/objects.html#tuple-types) */
declare type SerializeTuple<T extends [unknown, ...unknown[]]> = {
    [k in keyof T]: T[k] extends NonJsonPrimitive ? null : Serialize<T[k]>;
};
/** JSON serialize objects (not including arrays) and classes */
declare type SerializeObject<T extends object> = {
    [k in keyof T as T[k] extends NonJsonPrimitive ? never : k]: Serialize<T[k]>;
};
declare type UndefinedToOptional<T extends object> = Merge<{
    [k in keyof T as undefined extends T[k] ? never : k]: T[k];
}, {
    [k in keyof T as undefined extends T[k] ? k : never]?: Exclude<T[k], undefined>;
}>;
declare type ArbitraryFunction = (...args: any[]) => unknown;
/**
 * Infer JSON serialized data type returned by a loader or action.
 *
 * For example:
 * `type LoaderData = SerializeFrom<typeof loader>`
 */
export declare type SerializeFrom<T extends AppData | ArbitraryFunction> = Serialize<T extends (...args: any[]) => infer Output ? Awaited<Output> extends TypedResponse<infer U> ? U : Awaited<Output> : Awaited<T>>;
export {};
