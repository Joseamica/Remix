function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _classPrivateFieldGet(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");

  return _classApplyDescriptorGet(receiver, descriptor);
}

function _classPrivateFieldSet(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");

  _classApplyDescriptorSet(receiver, descriptor, value);

  return value;
}

function _classExtractFieldDescriptor(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }

  return privateMap.get(receiver);
}

function _classApplyDescriptorGet(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }

  return descriptor.value;
}

function _classApplyDescriptorSet(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }

    descriptor.value = value;
  }
}

function _classPrivateMethodGet(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }

  return fn;
}

function _checkPrivateRedeclaration(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}

function _classPrivateFieldInitSpec(obj, privateMap, value) {
  _checkPrivateRedeclaration(obj, privateMap);

  privateMap.set(obj, value);
}

function _classPrivateMethodInitSpec(obj, privateSet) {
  _checkPrivateRedeclaration(obj, privateSet);

  privateSet.add(obj);
}

var list = [
  " daum[ /]",
  " deusu/",
  "(?:^| )site",
  "@[a-z]",
  "\\(at\\)[a-z]",
  "\\(github\\.com/",
  "\\[at\\][a-z]",
  "^12345",
  "^<",
  "^[\\w \\.]+/v?\\d+(\\.\\d+)?(\\.\\d{1,10})?$",
  "^[\\w]+$",
  "^[^ ]{50,}$",
  "^ace explorer",
  "^acoon",
  "^active",
  "^ad muncher",
  "^anglesharp/",
  "^anonymous",
  "^apple-pubsub/",
  "^astute srm",
  "^avsdevicesdk/",
  "^axios/",
  "^bidtellect/",
  "^biglotron",
  "^blackboard safeassign",
  "^blocknote.net",
  "^braze sender",
  "^captivenetworksupport",
  "^castro",
  "^cf-uc ",
  "^clamav[ /]",
  "^cobweb/",
  "^coccoc",
  "^custom",
  "^dap ",
  "^ddg[_-]android",
  "^discourse",
  "^dispatch/\\d",
  "^downcast/",
  "^duckduckgo",
  "^email",
  "^enigma browser",
  "^evernote clip resolver",
  "^facebook",
  "^faraday",
  "^fdm[ /]\\d",
  "^getright/",
  "^gozilla/",
  "^hatena",
  "^hobbit",
  "^hotzonu",
  "^hwcdn/",
  "^infox-wisg",
  "^invision",
  "^jeode/",
  "^jetbrains",
  "^jetty/",
  "^jigsaw",
  "^linkdex",
  "^lwp[-: ]",
  "^mailchimp\\.com$",
  "^metauri",
  "^microsoft bits",
  "^microsoft data",
  "^microsoft office existence",
  "^microsoft office protocol discovery",
  "^microsoft windows network diagnostics",
  "^microsoft-cryptoapi",
  "^microsoft-webdav-miniredir",
  "^movabletype",
  "^mozilla/\\d\\.\\d \\(compatible;?\\)$",
  "^mozilla/\\d\\.\\d \\w*$",
  "^my browser$",
  "^navermailapp",
  "^netsurf",
  "^nginx\\W",
  "^node-superagent",
  "^octopus",
  "^offline explorer",
  "^pagething",
  "^panscient",
  "^perimeterx",
  "^php",
  "^postman",
  "^postrank",
  "^python",
  "^read",
  "^reed",
  "^request-promise$",
  "^restsharp/",
  "^shareaza",
  "^shockwave flash",
  "^snapchat",
  "^space bison",
  "^sprinklr",
  "^svn",
  "^swcd ",
  "^t-online browser",
  "^taringa",
  "^test certificate info",
  "^the knowledge ai",
  "^thinklab",
  "^thumbor/",
  "^traackr.com",
  "^tumblr/",
  "^vbulletin",
  "^venus/fedoraplanet",
  "^w3c",
  "^webbandit/",
  "^webcopier",
  "^wget",
  "^whatsapp",
  "^www-mechanize",
  "^xenu link sleuth",
  "^yahoo",
  "^yandex",
  "^zdm/\\d",
  "^zeushdthree",
  "^zoom marketplace/",
  "adbeat\\.com",
  "appinsights",
  "archive",
  "ask jeeves/teoma",
  "bit\\.ly/",
  "bluecoat drtr",
  "bot",
  "browsex",
  "burpcollaborator",
  "capture",
  "catch",
  "check",
  "chrome-lighthouse",
  "chromeframe",
  "client",
  "cloud",
  "crawl",
  "daemon",
  "dareboost",
  "datanyze",
  "dataprovider",
  "dejaclick",
  "dmbrowser",
  "download",
  "evc-batch/",
  "feed",
  "fetch",
  "firephp",
  "freesafeip",
  "ghost",
  "gomezagent",
  "google",
  "headlesschrome/",
  "http",
  "httrack",
  "hubspot marketing grader",
  "hydra",
  "ibisbrowser",
  "images",
  "index",
  "ips-agent",
  "java",
  "library",
  "mail\\.ru/",
  "manager",
  "monitor",
  "morningscore/",
  "neustar wpm",
  "news",
  "nutch",
  "offbyone",
  "optimize",
  "pagespeed",
  "parse",
  "perl",
  "phantom",
  "pingdom",
  "powermarks",
  "preview",
  "probe",
  "proxy",
  "ptst[ /]\\d",
  "reader",
  "rexx;",
  "rigor",
  "rss",
  "scan",
  "scrape",
  "search",
  "serp ?reputation ?management",
  "server",
  "sogou",
  "sparkler/",
  "spider",
  "statuscake",
  "stumbleupon\\.com",
  "supercleaner",
  "synapse",
  "synthetic",
  "taginspector/",
  "toolbar",
  "torrent",
  "tracemyfile",
  "transcoder",
  "trendsmapresolver",
  "twingly recon",
  "url",
  "valid",
  "virtuoso",
  "wappalyzer",
  "webglance",
  "webkit2png",
  "websitemetadataretriever",
  "whatcms/",
  "wordpress",
  "zgrab"
];

/**
 * Mutate given list of patter strings
 * @param {string[]} list
 * @returns {string[]}
 */
function amend(list) {
  try {
    // Risk: Uses lookbehind assertion, avoid breakage in parsing by using RegExp constructor
    new RegExp('(?<! cu)bot').test('dangerbot'); // eslint-disable-line prefer-regex-literals
  } catch (error) {
    // Skip regex fixes
    return list;
  } // Addresses: Cubot device


  list.splice(list.lastIndexOf('bot'), 1);
  list.push('(?<! cu)bot'); // Addresses: Android webview

  list.splice(list.lastIndexOf('google'), 1);
  list.push('(?<! (channel/|google/))google(?!(app|/google| pixel))'); // Addresses: Yandex browser

  list.splice(list.lastIndexOf('search'), 1);
  list.push('(?<! (ya|yandex))search'); // Addresses: libhttp browser

  list.splice(list.lastIndexOf('http'), 1);
  list.push('(?<!(lib))http'); // Addresses: java based browsers

  list.splice(list.lastIndexOf('java'), 1);
  list.push('java(?!;)'); // Addresses: Mozilla nightly build https://github.com/mozilla-mobile/android-components/search?q=MozacFetch

  list.splice(list.lastIndexOf('fetch'), 1);
  list.push('(?<!(mozac))fetch');
  return list;
}

amend(list);
var flags = 'i';
/**
 * Test user agents for matching patterns
 */

var _list = /*#__PURE__*/new WeakMap();

var _pattern = /*#__PURE__*/new WeakMap();

var _update = /*#__PURE__*/new WeakSet();

var _index = /*#__PURE__*/new WeakSet();

var Isbot = /*#__PURE__*/function () {
  /**
   * @type {string[]}
   */

  /**
   * @type {RegExp}
   */
  function Isbot(patterns) {
    var _this = this;

    _classCallCheck(this, Isbot);

    _classPrivateMethodInitSpec(this, _index);

    _classPrivateMethodInitSpec(this, _update);

    _classPrivateFieldInitSpec(this, _list, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldInitSpec(this, _pattern, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldSet(this, _list, patterns || list.slice());

    _classPrivateMethodGet(this, _update, _update2).call(this);

    var isbot = function isbot(ua) {
      return _this.test(ua);
    };

    return Object.defineProperties(isbot, Object.getOwnPropertyNames(Isbot.prototype).filter(function (prop) {
      return !['constructor'].includes(prop);
    }).reduce(function (accumulator, prop) {
      return Object.assign(accumulator, _defineProperty({}, prop, {
        get: function get() {
          return _this[prop].bind(_this);
        }
      }));
    }, {}));
  }
  /**
   * Recreate the pattern from rules list
   */


  _createClass(Isbot, [{
    key: "test",
    value:
    /**
     * Match given string against out pattern
     * @param  {string} ua User Agent string
     * @returns {boolean}
     */
    function test(ua) {
      return Boolean(ua) && _classPrivateFieldGet(this, _pattern).test(ua);
    }
    /**
     * Get the match for strings' known crawler pattern
     * @param  {string} ua User Agent string
     * @returns {string|null}
     */

  }, {
    key: "find",
    value: function find() {
      var ua = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var match = ua.match(_classPrivateFieldGet(this, _pattern));
      return match && match[0];
    }
    /**
     * Get the patterns that match user agent string if any
     * @param  {string} ua User Agent string
     * @returns {string[]}
     */

  }, {
    key: "matches",
    value: function matches() {
      var ua = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      return _classPrivateFieldGet(this, _list).filter(function (entry) {
        return new RegExp(entry, flags).test(ua);
      });
    }
    /**
     * Clear all patterns that match user agent
     * @param  {string} ua User Agent string
     * @returns {void}
     */

  }, {
    key: "clear",
    value: function clear() {
      var ua = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      this.exclude(this.matches(ua));
    }
    /**
     * Extent patterns for known crawlers
     * @param  {string[]} filters
     * @returns {void}
     */

  }, {
    key: "extend",
    value: function extend() {
      var _this2 = this;

      var filters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      [].push.apply(_classPrivateFieldGet(this, _list), filters.filter(function (rule) {
        return _classPrivateMethodGet(_this2, _index, _index2).call(_this2, rule) === -1;
      }).map(function (filter) {
        return filter.toLowerCase();
      }));

      _classPrivateMethodGet(this, _update, _update2).call(this);
    }
    /**
     * Exclude patterns from bot pattern rule
     * @param  {string[]} filters
     * @returns {void}
     */

  }, {
    key: "exclude",
    value: function exclude() {
      var filters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var length = filters.length;

      while (length--) {
        var index = _classPrivateMethodGet(this, _index, _index2).call(this, filters[length]);

        if (index > -1) {
          _classPrivateFieldGet(this, _list).splice(index, 1);
        }
      }

      _classPrivateMethodGet(this, _update, _update2).call(this);
    }
    /**
     * Create a new Isbot instance using given list or self's list
     * @param  {string[]} [list]
     * @returns {Isbot}
     */

  }, {
    key: "spawn",
    value: function spawn(list) {
      return new Isbot(list || _classPrivateFieldGet(this, _list));
    }
  }]);

  return Isbot;
}();

function _update2() {
  _classPrivateFieldSet(this, _pattern, new RegExp(_classPrivateFieldGet(this, _list).join('|'), flags));
}

function _index2(rule) {
  return _classPrivateFieldGet(this, _list).indexOf(rule.toLowerCase());
}

var isbot = new Isbot();

module.exports = isbot;
//# sourceMappingURL=index.js.map
